# Уровни абстракции в проекте iXe

## Введение

Этот документ фиксирует ключевое понимание архитектуры проекта iXe: как связаны между собой интерфейсы, адаптеры и сервисы, и как они организованы на разных уровнях абстракции в соответствии с принципами Clean Architecture.

## Уровни абстракции

Проект iXe организован по принципам Чистой Архитектуры (Clean Architecture), где каждый уровень имеет свою зону ответственности и уровень абстракции. Ниже описаны ключевые уровни и их компоненты:

### 1. Доменный уровень (Domain Layer) - Наивысший уровень абстракции

**Ответственность:**
- Определение бизнес-объектов и правил.
- Определение абстракций (интерфейсов) для всех внешних зависимостей.
- Хранение доменных исключений.

**Компоненты:**
- `domain/interfaces/` - содержит абстракции (интерфейсы), определяющие "что" должно быть реализовано, но не "как".
  - `ITaskNumberInferer` - интерфейс для определения номера задачи ЕГЭ по КЭС-кодам.
  - `ITaskClassifier` - интерфейс для классификации задач по сложности и типу.
  - `IHTMLProcessor` - интерфейс для обработки HTML-контента.
- `domain/exceptions/` - иерархия исключений, специфичных для предметной области.

**Цель:** Этот уровень не зависит ни от каких других уровней. Он определяет "ядро" бизнес-логики и контракты для взаимодействия с внешним миром.

### 2. Прикладной уровень (Application Layer) - Средний уровень абстракции

**Ответственность:**
- Реализация прикладной бизнес-логики.
- Оркестрация операций между доменным и инфраструктурными уровнями.
- Использование доменных интерфейсов для взаимодействия с инфраструктурой.

**Компоненты:**
- `application/services/` - содержит прикладные сервисы, которые координируют выполнение задач, используя доменные интерфейсы.
  - `HTMLProcessingService` - сервис, который координирует обработку HTML, полагаясь на `IHTMLProcessor`.
  - `TaskProcessingService` - сервис, который координирует обработку и классификацию задач, полагаясь на `ITaskClassifier` и `ITaskNumberInferer`.

**Цель:** Этот уровень зависит от доменного уровня (через интерфейсы), но не зависит от инфраструктуры. Он определяет "как" использовать доменные абстракции для выполнения конкретных задач приложения.

### 3. Инфраструктурный уровень (Infrastructure Layer) - Наименьший уровень абстракции

**Ответственность:**
- Реализация доменных интерфейсов.
- Взаимодействие с внешними системами (базы данных, векторные хранилища, браузеры).
- Предоставление конкретных реализаций, зависящих от внешних библиотек или фреймворков.

**Компоненты:**
- `infrastructure/adapters/` - содержит адаптеры, которые реализуют доменные интерфейсы.
  - `TaskNumberInfererAdapter` - конкретная реализация `ITaskNumberInferer`.
  - `TaskClassifierAdapter` - конкретная реализация `ITaskClassifier`.
  - `BlockProcessorAdapter` - конкретная реализация `IHTMLProcessor`.

**Цель:** Этот уровень зависит от доменного уровня (реализуя его интерфейсы), но сам может зависеть от внешних библиотек. Он определяет "как именно" реализованы абстракции, определенные на доменном уровне.

## Взаимосвязь компонентов

| Тип компонента | Уровень | Назначение | Пример в проекте |
|----------------|---------|------------|------------------|
| **Интерфейс** | Доменный | Определяет контракт ("что"), не завися от реализации | `ITaskNumberInferer` |
| **Сервис** | Прикладной | Оркестрирует логику, используя интерфейсы | `TaskProcessingService` |
| **Адаптер** | Инфраструктурный | Реализует интерфейс, адаптируя внешнюю логику к доменному контракту | `TaskNumberInfererAdapter` |

### Пример взаимодействия:

1. **Прикладной сервис** (`TaskProcessingService`) нуждается в определении номера задачи.
2. Он объявляет зависимость от **доменного интерфейса** (`ITaskNumberInferer`).
3. В момент инъекции зависимостей, **инфраструктурный адаптер** (`TaskNumberInfererAdapter`), который *реализует* `ITaskNumberInferer`, передается в сервис.
4. Сервис вызывает методы через интерфейс, не зная о конкретной реализации.
5. Адаптер выполняет конкретную логику (например, анализирует КЭС-коды по спецификации ФИПИ).

## Значение для проекта

- **Четкое разделение ответственности:** Каждый уровень решает свои задачи.
- **Тестируемость:** Прикладные сервисы можно тестировать, подставляя моки интерфейсов.
- **Гибкость:** Можно легко заменить реализацию адаптера, не меняя прикладной логики.
- **Соблюдение DIP:** Модули верхних уровней не зависят от модулей нижних уровней, оба зависят от абстракций.
- **Предотвращение циклических зависимостей:** Благодаря строгой иерархии зависимости направлены только внутрь, к доменному ядру.

