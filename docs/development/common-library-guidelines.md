# Руководство по использованию common/

## Структура
`common/` организована по модулям, отражающим функциональность:
- `models/`: Pydantic и SQLAlchemy модели данных.
- `utils/`: Stateless утилиты (конвертеры, мапперы, вспомогательные функции).
- `processors/`: Обработчики данных (например, `page_processor`, `block_processor`).
- `services/`: Сервисы с общей логикой (например, `specification`).
- `config/`: Конфигурационные файлы (JSON, правила и т.д.).

## Правила включения в common/

### ✅ Можно включать:
- **Модели данных:** Pydantic-схемы и SQLAlchemy ORM-модели, используемые несколькими компонентами.
- **Stateless-утилиты:** Функции и классы, не имеющие внутреннего состояния или имеющие состояние, безопасное для совместного использования.
- **Конфигурации:** Файлы конфигурации, используемые несколькими компонентами.
- **Специфичная бизнес-логика:** Логика, не зависящая от конкретной реализации сервиса (например, `TaskNumberInferer`).

### ❌ Нельзя включать:
- **Компоненты с тяжёлыми зависимостями:** Файлы, импортирующие `playwright`, `qdrant_client`, `BrowserManager`, `Retriever`, `VectorIndexer` и т.д. (если они не являются частью `common`).
- **Stateful-классы (Singleton и т.п.):** Классы, управляющие глобальным состоянием (например, `BrowserManager` до его рефакторинга).
- **Логика, специфичная для одного сервиса:** Код, который не используется минимум двумя другими компонентами проекта.
- **Зависимости от компонентов вне common:** Избегать импортов из `api/`, `scraper/`, `scripts/` и т.д.

## Процесс обновления импортов
После переноса файла в `common`:
1.  Обновить все импорты этого файла в остальной части проекта (например, `from models.problem_schema import Problem` -> `from common.models.problem_schema import Problem`).
2.  Удалить исходный файл из старой директории (после подтверждения корректности импортов).
