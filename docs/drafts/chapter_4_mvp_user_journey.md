# Глава 4: MVP Сценарий Пользователя - Путь от Приветствия до Калибровки

## 4.1. Введение: Определение MVP

После рефакторинга внутренней архитектуры в предыдущих главах, мы готовы спроектировать и реализовать минимально жизнеспособный продукт (MVP), демонстрирующий ключевые функции платформы iXe. MVP охватывает путь пользователя от входа в PWA-приложение до прохождения начальной калибровки навыков по выбранному предмету.

**Цель MVP:**
- Продемонстрировать цепочку "Выбор предмета -> (Опциональный скрапинг) -> Выбор режима -> Калибровка".
- Проверить работоспособность интеграции между скрапингом, хранением, проверкой ответов и адаптивной логикой.
- Предоставить основу для итеративного добавления новых функций (тестовый экзамен, адаптивные задания).

## 4.2. Архитектурные предпосылки для MVP

Перед тем как погрузиться в сценарий пользователя, важно понять, как архитектурные изменения из предыдущих глав поддерживают реализацию MVP.

- **Сервисы прикладного уровня** (`QuizService`, `AnswerService`, `ScrapingOrchestrator`): Эти сервисы координируют сложные сценарии, изолируя бизнес-логику от инфраструктуры и API.
- **Интерфейсы репозиториев** (`IProblemRepository`, `IUserProgressRepository`): Позволяют `QuizService` и `AnswerService` работать с данными, не привязываясь к конкретной базе (пока SQLite, но готовы к ArangoDB).
- **Инфраструктурные адаптеры** (`FIPIAnswerCheckerAdapter`, `DatabaseAdapter`): Инкапсулируют взаимодействие с внешними системами (браузер, база данных).
- **Доменные сущности** (`Problem`, `UserProgress`): Содержат инварианты и базовую логику, относящуюся к задачам и прогрессу.

## 4.3. Сценарий Пользователя: Подробное Погружение

Рассмотрим путь пользователя, обозначенного как `User`, через MVP.

### Шаг 1: Вход в PWA и Приветствие

- **Пользователь**: Открывает PWA iXe.
- **Система (Frontend)**: Отображает приветственный экран.
- **Система (Backend - `api/endpoints/subjects.py`)**:
  - Вызывается эндпоинт `GET /subjects/available`.
  - `CLIScraper.get_available_subjects()` (или новый сервис, возвращающий список из конфигурации/базы) предоставляет список предметов.
  - API возвращает `AvailableSubjectsResponse`.

```python
# api/endpoints/subjects.py
from fastapi import APIRouter
from api.dependencies import get_subject_list_service # Новый сервис для получения списка
from api.schemas import AvailableSubjectsResponse

router = APIRouter()

@router.get("/available", response_model=AvailableSubjectsResponse)
async def get_available_subjects(service = Depends(get_subject_list_service)):
    subjects = await service.get_available() # Вызов сервиса
    return AvailableSubjectsResponse(subjects=subjects)
```

- **Пользователь**: Видит список предметов ЕГЭ (например, "Математика. Базовый уровень", "Информатика", "Физика").

### Шаг 2: Выбор Предмета

- **Пользователь**: Выбирает один или несколько предметов (например, "Математика. Базовый уровень").
- **Система (Frontend)**: Отправляет выбранный `subject_key` на бэкенд.
- **Система (Backend - `api/endpoints/quiz.py`)**:
  - Вызывается эндпоинт `POST /quiz/start` с `StartQuizRequest(page_name=subject_key)`.
  - `QuizService.start_quiz(request, db_manager)` вызывается внутри эндпоинта.

### Шаг 3: Проверка Наличия Заданий / Запуск Скрапинга

- **Система (`QuizService`)**:
  - Проверяет количество задач в `IProblemRepository` для выбранного `subject_key`.
  - Если задач *недостаточно* (например, `repo.get_count_by_subject(subject_key) < MIN_REQUIRED_TASKS`), `QuizService` *не* запускает скрапинг напрямую. В MVP скрапинг запускается отдельно (например, администратором или по расписанию), а не пользователем.
  - Если задач *достаточно*, `QuizService` переходит к выбору режима.
- **Система (Frontend)**: В зависимости от ответа бэкенда, либо отображает экран "Данные для {предмета} обновляются, попробуйте позже", либо переходит к следующему шагу.

*Примечание: В расширенной версии `QuizService` может вызывать `ScrapingOrchestrator`, но в MVP это выносится за пределы пользовательского сценария.*

### Шаг 4: Выбор Режима (Калибровка, Экзамен, Адаптивно)

- **Система (Frontend)**: Отображает экран с интерактивными элементами:
  - "Пройти калибровку навыков"
  - "Пройти тестовый экзамен"
  - "Рекомендованные задания"
- **Пользователь**: Выбирает "Пройти калибровку навыков".

### Шаг 5: Сценарий Калибровки

#### 5.1. Инициализация Калибровки

- **Система (Backend - `api/endpoints/quiz.py`)**: Вызывается `POST /quiz/start` с указанием режима калибровки (например, через поле `mode` в `StartQuizRequest`).
- **Система (`QuizService.start_quiz`)**:
  - Определяет, что выбран режим калибровки.
  - Вызывает `QuizService._get_calibration_problems(db_manager, subject_key)`.
  - Эта функция (или новый `CalibrationService`) использует `IProblemRepository` и `ISpecificationProvider` (через `get_spec_service` из `dependencies.py`) для выбора задач, охватывающих все типы задач (1-19) и, возможно, ключевые KOS/KES из спецификации.
  - Возвращает список задач (например, 19 задач, по одной на каждый номер задания ЕГЭ).

#### 5.2. Отображение Задач и Ввод Ответа

- **Система (Frontend)**: Получает `StartQuizResponse` с первой задачей из калибровочного набора.
- **Пользователь**: Видит задачу в интерактивном HTML-формате (с обработанными изображениями, формулами) и поле ввода.
- **Пользователь**: Вводит ответ и нажимает "Проверить".

#### 5.3. Проверка Ответа

- **Система (Frontend)**: Отправляет `CheckAnswerRequest(problem_id=..., answer=...)` на `POST /answer/check`.
- **Система (Backend - `api/endpoints/answer.py`)**: Вызывает `AnswerService.check_answer(...)`.
- **Система (`AnswerService`)**:
  - Проверяет кэш (`ICacheProvider`).
  - Если ответ не найден в кэше, вызывает `IExternalChecker.check_answer(...)` (реализованный как `FIPIAnswerCheckerAdapter`).
  - `FIPIAnswerCheckerAdapter` использует `BrowserPoolManager` для открытия страницы, ввода ответа и определения результата (верно/неверно).
  - Результат сохраняется в `IStorageProvider` (реализованный как `LocalStorageAdapter` или `IUserProgressRepository`).
  - `AnswerService` генерирует `CheckAnswerResponse` с результатом и обратной связью.

#### 5.4. Продолжение Калибровки

- **Система (Frontend)**: Отображает результат проверки текущей задачи.
- **Пользователь**: Нажимает "Следующее задание".
- **Система (Frontend)**: Запрашивает следующую задачу из калибровочного набора (или бэкенд может возвращать их по одной, обновляя внутреннее состояние квиза).
- **Цикл повторяется** (5.2-5.4) до тех пор, пока пользователь не выполнит *хотя бы по одному заданию каждого типа* (1-19) или не закончится набор задач.

#### 5.5. Финальный Экран Калибровки

- **Система (`QuizService` или новый `CalibrationService`)**: Определяет, что калибровка завершена (все типы задач пройдены).
- **Система (Backend)**: Возвращает `CheckAnswerResponse` с флагом `is_calibration_complete=True` и итогами (например, список пройденных типов, общее количество верных/неверных).
- **Система (Frontend)**: Отображает финальный экран калибровки:
  - Краткий отчет о результатах.
  - Кнопки "Назад" (в главное меню) и "В главное меню".

## 4.4. Архитектурные компоненты, задействованные в MVP

- **API Endpoints** (`api/endpoints/subjects.py`, `api/endpoints/quiz.py`, `api/endpoints/answer.py`): Точка входа для фронтенда.
- **Сервисы прикладного уровня** (`QuizService`, `AnswerService`): Основная логика сценариев.
- **Инфраструктурные адаптеры** (`FIPIAnswerCheckerAdapter`, `DatabaseAdapter`, `SpecificationAdapter`): Взаимодействие с внешними системами и базами данных.
- **Интерфейсы репозиториев** (`IProblemRepository`, `IUserProgressRepository`): Доступ к данным.
- **Доменные сущности** (`Problem`, `UserProgress`): Модель данных.
- **PWA Frontend**: Интерфейс взаимодействия с пользователем.

## 4.5. Выводы

Сценарий MVP "Путь от Приветствия до Калибровки" охватывает ключевые архитектурные слои проекта iXe. Он демонстрирует, как принципы DDD и чистая архитектура позволяют изолировать сложные сценарии (как проверка ответов через браузер) и координировать их с помощью сервисов прикладного уровня. Реализация этого MVP станет важной вехой, подтверждающей жизнеспособность выбранной архитектуры и готовностью к добавлению более сложных адаптивных функций в будущих итерациях.
