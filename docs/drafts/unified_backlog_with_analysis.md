# Единый приоритизированный бэклог: Проектирование предметной области и миграция на полиглотную персистентность

## 1. Проектирование предметной области (Domain-Driven Design)

### 1.1. Определение сущностей и агрегатов
- **Problem** (Агрегат)
  - ID, subject, type, text, difficulty_level, exam_part, max_score
  - answer, options, solutions, kes_codes, skills, task_number, kos_codes
  - form_id, source_url, raw_html_path, created_at, updated_at, metadata
- **Skill** (Агрегат)
  - ID, name, description, dependencies, related_problems
- **UserProgress** (Агрегат)
  - user_id, problem_id, skill_id, status, score, attempts, timestamp
- **UserInteractionEvent** (Агрегат)
  - user_id, problem_id, action, timestamp, payload

### 1.2. Определение Value Objects
- **ProblemId**: строковый идентификатор задачи с валидацией
- **UserId**: строковый идентификатор пользователя
- **TaskNumber**: номер задания ЕГЭ (1-19)
- **Score**: результат, ограниченный max_score

### 1.3. Определение доменных сервисов
- **IProblemService**: бизнес-логика, связанная с задачами
- **ISkillService**: бизнес-логика, связанная с навыками и зависимостями
- **IProgressService**: бизнес-логика, связанная с прогрессом пользователя

### 1.4. Определение репозиториев (интерфейсы)
- **IProblemRepository**: CRUD для агрегата Problem
- **ISkillRepository**: CRUD для агрегата Skill
- **IProgressRepository**: CRUD для агрегата UserProgress
- **IEventRepository**: CRUD для агрегата UserInteractionEvent

## 2. Выбор баз данных для хранения (Polyglot Persistence)

### 2.1. ArangoDB (Документы + Графы)
- **Назначение**: хранение агрегатов Problem и Skill, а также графа зависимостей
- **Преимущества**: native поддержка документов и графов, AQL, ACID
- **Использование**: IProblemRepository, ISkillRepository

### 2.2. Qdrant (Векторы)
- **Назначение**: хранение эмбеддингов задач для семантического поиска
- **Преимущества**: HNSW, hybrid search, специализированная оптимизация
- **Использование**: IVectorSearchService

### 2.3. PostgreSQL (События и временные данные)
- **Назначение**: хранение агрегата UserInteractionEvent
- **Преимущества**: надежность, поддержка JSON, ACID, масштабируемость
- **Альтернатива для SQLite**: значительно мощнее, подходит для продакшена
- **Использование**: IEventRepository

## 3. Приоритизированный бэклог задач

### Phase 1: Подготовка доменной модели
1. **Создать Value Objects** (ProblemId, UserId, TaskNumber, Score)
2. **Определить доменные сущности** (Problem, Skill, UserProgress, UserInteractionEvent)
3. **Определить интерфейсы репозиториев** (IProblemRepository, ISkillRepository, IProgressRepository, IEventRepository)
4. **Определить доменные сервисы** (IProblemService, ISkillService, IProgressService)
5. **Обновить existing модели** (Problem, database_models) под новые агрегаты

### Phase 2: Подготовка инфраструктуры
6. **Настроить ArangoDB** (Docker Compose, клиентская библиотека)
7. **Настроить Qdrant** (Docker Compose, клиентская библиотека)
8. **Настроить PostgreSQL** (Docker Compose, SQLAlchemy/SQLModel для событий)
9. **Создать миграции** для ArangoDB (коллекции, индексы)
10. **Создать миграции** для PostgreSQL (таблицы, индексы)

### Phase 3: Реализация адаптеров инфраструктуры
11. **ArangoDocumentAdapter** (реализация IProblemRepository)
12. **ArangoGraphAdapter** (реализация ISkillRepository)
13. **QdrantVectorAdapter** (реализация IVectorSearchService)
14. **PostgreSQLEventAdapter** (реализация IEventRepository)
15. **Обновить QuizService** для использования новых адаптеров

### Phase 4: Миграция данных
16. **Создать скрипт миграции** из SQLite в ArangoDB (problems)
17. **Создать скрипт миграции** для построения графа навыков
18. **Создать скрипт индексации** в Qdrant
19. **Создать скрипт миграции** из SQLite в PostgreSQL (events)

### Phase 5: Обновление точек входа и тестирование
20. **Обновить API** эндпоинты для использования новых сервисов
21. **Обновить скрипты** скрапинга для сохранения в новую архитектуру
22. **Написать/обновить модульные тесты** для новых адаптеров
23. **Написать/обновить интеграционные тесты** с контейнерами
24. **Провести сквозное тестирование** скрапинг -> сохранение -> поиск -> использование

## 4. Анализ по принципам книги "Паттерны разработки на Python"

### 4.1. Test-Driven Development (TDD)
- **Применимо**: 
  - Каждый новый адаптер (Phase 3) должен быть разработан по TDD: сначала тесты, потом реализация
  - Миграционные скрипты (Phase 4) должны быть протестированы на фикстурах
  - Сквозные тесты (Phase 5) обеспечивают уверенность в целостности системы
- **Рекомендация**: 
  - Начать с написания тестов для новых Value Objects и доменных сущностей (Phase 1)
  - Для каждого адаптера создать юнит-тесты с моками баз данных

### 4.2. Domain-Driven Design (DDD)
- **Применимо**:
  - Четкое разделение на слои (Domain, Application, Infrastructure)
  - Использование агрегатов и Value Objects для моделирования предметной области
  - Интерфейсы репозиториев в доменном слое (Dependency Inversion)
- **Рекомендация**:
  - Убедиться, что доменные сущности содержат бизнес-логику (инварианты)
  - Доменные сервисы должны содержать логику, не принадлежащую конкретной сущности
  - Адаптеры инфраструктуры реализуют интерфейсы, определенные в доменном слое

### 4.3. Событийно-ориентированная архитектура (Event-Driven Architecture)
- **Применимо**:
  - Агрегат UserInteractionEvent и IEventRepository поддерживают событийный подход
  - Возможность генерировать события при сохранении прогресса или взаимодействии
  - Использование событий для триггера обновления векторных индексов
- **Рекомендация**:
  - Рассмотреть добавление Event Publisher/Subscriber для обработки событий прогресса
  - События могут использоваться для триггера пересчета навыков или адаптивной логики

### 4.4. Общие архитектурные принципы
- **Разделение ответственностей**: Каждый адаптер отвечает за свою модель данных
- **Открытость/закрытость**: Система открыта для расширения (новые адаптеры), закрыта для модификации (через интерфейсы)
- **Инверсия зависимостей**: зависимости направлены к доменному слою
- **Тестируемость**: использование интерфейсов позволяет легко мокать зависимости

## 5. Выводы

Предложенный бэклог полностью соответствует принципам DDD и TDD. 
- **Domain-Driven Design** реализуется через четкое моделирование агрегатов, Value Objects и интерфейсов репозиториев в доменном слое.
- **TDD** применим на этапах реализации адаптеров и миграционных скриптов.
- **Событийно-ориентированная архитектура** поддерживается через агрегат UserInteractionEvent и потенциальные события прогресса.
- Архитектура позволяет эффективно использовать специализированные базы данных (ArangoDB, Qdrant, PostgreSQL) для оптимального хранения разных типов данных (документы, графы, векторы, события).
- Миграция с текущей SQLite-центричной архитектуры на полиглотную персистентность требует тщательного планирования и тестирования, но даст значительные преимущества в долгосрочной перспективе.
