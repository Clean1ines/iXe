Хорошо, давайте спланируем **тестирование** и **документирование** для вашего проекта iXe, учитывая архитектурные изменения, введение `common` библиотеки и цели монетизации.

---

### **План Тестирования и Документирования для iXe**

**Цель:** Обеспечить надежность, стабильность и сопровождаемость приложения после перехода к микросервисной архитектуре с `common` библиотекой и интеграцией Supabase/Qdrant. Подготовить документацию для разработчиков и, при необходимости, для пользователей.

---

### **I. Тестирование**

#### **1. Стратегия тестирования**

*   **Модульное тестирование (Unit Tests):** Проверяет *отдельные компоненты* (функции, классы) в изоляции. Цель — убедиться, что каждый кирпичик работает правильно.
*   **Интеграционное тестирование (Integration Tests):** Проверяет *взаимодействие* между компонентами (например, `AnswerService` <-> `CheckerClient`, `QuizService` <-> `DatabaseManager` <-> `SearchClient`). Цель — убедиться, что части работают вместе.
*   **Сквозное/Функциональное тестирование (E2E Tests):** Проверяет *конечные пользовательские сценарии* через API. Цель — убедиться, что приложение работает как единое целое от входа пользователя до получения результата.
*   **Тестирование производительности (Load Tests):** (Позже) Проверяет, как приложение справляется с высокой нагрузкой.
*   **Тестирование безопасности:** (Позже) Проверяет уязвимости.

#### **2. Организация тестов в проекте (с учетом `common/`, `web-api-service`, `checker-service` и т.д.)**

*   **Структура:** Для каждого сервиса (и `common`) создайте папку `tests/` с подпапками `unit/`, `integration/`, `e2e/`.
    ```
    .
    ├── common/
    │   ├── models/
    │   ├── utils/
    │   ├── services/
    │   └── tests/
    │       ├── unit/
    │       │   ├── test_models/
    │       │   └── test_utils/
    │       └── integration/
    │           └── test_service_integration.py
    ├── web-api-service/
    │   ├── api/
    │   ├── services/
    │   ├── database/
    │   ├── clients/
    │   └── tests/
    │       ├── unit/
    │       │   ├── test_services/
    │       │   └── test_clients/
    │       ├── integration/
    │       │   ├── test_api_endpoints/
    │       │   └── test_service_deps.py
    │       └── e2e/
    │           └── test_user_journey.py
    ├── checker-service/
    │   ├── services/
    │   ├── utils/
    │   └── tests/
    │       ├── unit/
    │       └── integration/
    │           └── test_answer_checking.py
    ├── indexer-service/
    │   └── tests/
    │       ├── unit/
    │       └── integration/
    │           └── test_indexing.py
    ├── search-service/
    │   └── tests/
    │       ├── unit/
    │       └── integration/
    │           └── test_search.py
    └── tests/ # (опционально, для общих e2e или инфраструктурных тестов)
    ```
*   **Инструменты:** Используйте `pytest` как основной фреймворк. `pytest-asyncio` для асинхронных тестов. `pytest-mock` для мокирования. `httpx` или `requests` для тестирования API.
*   **Фикстуры (`conftest.py`):** Создавайте фикстуры для часто используемых объектов (например, `DatabaseManager`, `CheckerClient`, `QuizService`, тестовые данные) в `conftest.py` на соответствующем уровне (сервиса, `common`).
*   **Мокирование:** Активно используйте `pytest-mock` или `unittest.mock` для изоляции тестируемых компонентов от внешних зависимостей (например, `CheckerClient` в `AnswerService` тестах мокается, чтобы не вызывать реальный `checker-service`).

#### **3. Покрытие тестами ключевых компонентов**

*   **`common/`:**
    *   **Модели Pydantic (`common/models/pydantic_models.py`):** Проверить валидацию данных.
    *   **Модели SQLAlchemy (`common/models/database_models.py`):** Проверить маппинг, отношения (если есть), но *не* подключение к реальной БД.
    *   **Утилиты (`common/utils/`):** Проверить функции вроде `task_id_utils.py`, `subject_mapping.py`, `task_number_inferer.py` на корректность логики.
    *   **Сервисы (`common/services/specification.py`):** Проверить логику получения спецификаций.
*   **`web-api-service`:**
    *   **`database/database_manager.py`:** Тесты на подключение к *тестовой* БД (например, `in-memory SQLite` или `PostgreSQL` через `pytest-docker`), CRUD операции.
    *   **`clients/checker_client.py`, `clients/search_client.py`:** Тесты на корректные HTTP-запросы и обработку ответов/ошибок (мокирование `httpx`).
    *   **`services/answer_service.py`, `services/quiz_service.py`:** Мокировать зависимости (`DatabaseManager`, `CheckerClient`, `SearchClient`, `SpecificationService`) и проверить логику сервиса.
    *   **`api/endpoints/*.py`:** Интеграционные тесты FastAPI, проверяющие корректность обработки запросов, валидацию Pydantic-схем, вызов сервисов, возврат корректных HTTP-статусов. Использовать `TestClient` из `fastapi.testclient`.
*   **`checker-service`:**
    *   **`services/answer_checker.py`:** Тесты логики проверки (мокирование `BrowserManager`).
    *   **`utils/browser_manager.py`, `utils/browser_pool_manager.py`:** Сложно тестировать *реальные* браузеры. Сфокусироваться на логике управления (мокирование `playwright`).
    *   **API эндпоинты:** Проверить корректность обработки запросов и вызова `AnswerChecker`.
*   **`indexer-service`, `search-service`:**
    *   Аналогично `checker-service`, сфокусироваться на логике и API, мокируя `qdrant-client` и `DatabaseManager` (для чтения задач) в юнит-тестах.

#### **4. Запуск тестов**

*   **Конфигурация (`pytest.ini` в корне проекта или в каждом сервисе):**
    ```ini
    [tool:pytest]
    testpaths = tests
    asyncio_mode = auto
    addopts = -v --tb=short
    # Опционально: фильтры, плагины
    ```
*   **Запуск:**
    *   В корне `web-api-service`: `pytest tests/unit/` для юнит-тестов.
    *   В корне `web-api-service`: `pytest tests/integration/` для интеграционных тестов.
    *   В корне `web-api-service`: `pytest tests/e2e/` для E2E тестов (требует запущенных зависимостей).
    *   В корне `checker-service`: `pytest tests/unit/` и `pytest tests/integration/`.

#### **5. Покрытие кода (Coverage)**

*   Использовать `pytest-cov`: `pytest --cov=web_api_service --cov=common tests/unit/`.
*   Стремиться к высокому (например, >80%) покрытию *критических* путей выполнения.

---

### **II. Документирование**

#### **1. Цели документирования**

*   **Для разработчиков:** Понимание архитектуры, API, процесса разработки, тестирования, деплоя.
*   **Для пользователей (опционально):** Понимание функционала, инструкции по использованию (через PWA/Telegram).
*   **Для DevOps:** Понимание процесса сборки, деплоя, мониторинга.

#### **2. Типы документации**

*   **Кодовая документация:**
    *   **Docstrings:** Использовать `Google` или `Sphinx` стиль в модулях, классах, методах и функциях. Особенно важно для `common` компонентов и публичных API сервисов.
    *   **Комментарии:** Объяснять *сложную* или *нестандартную* логику.
*   **Техническая документация (`docs/`):**
    *   **`README.md` (в корне проекта и в каждом сервисе):** Краткое описание, архитектура, как запустить локально, как запустить тесты, как развернуть.
    *   **`docs/architecture/`:** Описание архитектурных решений (ADR - Architectural Decision Records), диаграммы (например, PlantUML, Mermaid).
    *   **`docs/api/`:** Документация API (например, сгенерированная из FastAPI `Swagger/OpenAPI`, или вручную).
    *   **`docs/data/`:** Описание структуры БД (Supabase, Qdrant), форматов задач, ответов.
    *   **`docs/development/`:** Руководство по разработке, стандарты кодирования (Black, isort), структура проекта.
    *   **`docs/deployment/`:** Руководство по деплою на Render (и другие платформы), переменные окружения.
*   **Пользовательская документация (опционально):**
    *   **`frontend/public/`:** `README.md` или `docs/` внутри `frontend/` с инструкцией по использованию PWA.
    *   **Telegram Bot Description:** Текст описания бота.

#### **3. Инструменты документирования**

*   **Для API:** FastAPI автоматически генерирует `/docs` (Swagger) и `/redoc`.
*   **Для кода:** `Sphinx` (сложнее), `pdoc` (проще) для генерации HTML-документации из docstrings.
*   **Для диаграмм:** PlantUML, Mermaid (вставляются в Markdown).
*   **Для ADR:** Простые Markdown-файлы в `docs/adr/`.

#### **4. Поддержка документации**

*   **Обновление:** Документация обновляется *вместе* с кодом при каждом значительном изменении (через PR).
*   **Проверка:** Включить проверку документации (например, наличие docstrings) в CI/CD pipeline (опционально, через `flake8` с плагинами или `pydocstyle`).

---

### **III. Интеграция в CI/CD (Контекст Git)**

*   **`.github/workflows/test.yml` (или аналог для вашей платформы CI):**
    *   Запуск `pytest` для каждого сервиса при пуше/мердже в ветку (например, `main`, `develop`).
    *   Проверка покрытия кода.
    *   Проверка форматирования (`black`, `isort`) и линтинга (`flake8`, `mypy`).
    *   Проверка сборки Docker-образов.
*   **Деплой:**
    *   После успешного прохождения CI, автоматический деплой на Render (или другую платформу) для ветки `main`.

---

### **Вывод:**

План тестирования и документирования интегрирован в архитектурный рефакторинг. Он учитывает структуру `common` библиотеки и микросервисов. Правильное тестирование (на разных уровнях) и актуальная документация *критически важны* для стабильности, сопровождаемости и успешной монетизации вашего приложения iXe. Реализация этого плана требует времени, но окупается в долгосрочной перспективе.