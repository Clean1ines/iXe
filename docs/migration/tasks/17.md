#### **Задача 17 (обновленная): Реализовать `POST /api/v1/subscribe` и проверку подписки. (Детализация)**

**Цель:** Добавить логику подписки.

**Действия:**

1.  **Обновление `database_manager.py` для работы с подписками:**
    *   **Добавить в `common/models/database_models.py` (или создать `DBSubscription` в `web-api-service/database/database_models.py`, если логика уникальна для API):**
        ```python
        # В common/models/database_models.py или в web-api-service/database/database_models.py
        from sqlalchemy import Column, Integer, String, DateTime, ForeignKey
        from sqlalchemy.orm import declarative_base
        # ... другие импорты ...

        Base = declarative_base() # Или используйте существующую

        class DBSubscription(Base):
            __tablename__ = 'subscriptions'

            id = Column(Integer, primary_key=True, index=True)
            user_id = Column(Integer, ForeignKey('users.id'), nullable=False) # Предполагаем, что есть таблица users
            status = Column(String, nullable=False) # 'active', 'inactive', 'expired', etc.
            start_date = Column(DateTime, nullable=False)
            end_date = Column(DateTime, nullable=False)
            created_at = Column(DateTime, default=func.now()) # Импортируйте func из sqlalchemy
        ```
    *   **Добавить методы в `web-api-service/database/database_manager.py`:**
        ```python
        # ... в классе DatabaseManager ...
        from sqlalchemy import select
        from common.models.database_models import DBSubscription # Импортируем ORM модель

        # ... существующие методы ...

        async def get_user_subscription_status(self, user_id: int) -> Optional[DBSubscription]:
            async with self.async_session() as session:
                try:
                    result = await session.execute(
                        select(DBSubscription).where(DBSubscription.user_id == user_id).order_by(DBSubscription.created_at.desc())
                    )
                    return result.scalar_one_or_none() # Берем последнюю подписку
                except SQLAlchemyError as e:
                    logger.error(f"Error fetching subscription for user {user_id}: {e}")
                    raise

        async def create_subscription(self, user_id: int, status: str, start_date: datetime, end_date: datetime) -> DBSubscription:
            async with self.async_session() as session:
                try:
                    db_subscription = DBSubscription(user_id=user_id, status=status, start_date=start_date, end_date=end_date)
                    session.add(db_subscription)
                    await session.commit()
                    await session.refresh(db_subscription)
                    return db_subscription
                except SQLAlchemyError as e:
                    logger.error(f"Error creating subscription for user {user_id}: {e}")
                    await session.rollback()
                    raise
        ```

2.  **Создание эндпоинта `POST /api/v1/subscribe` в `web-api-service/api/endpoints/`:**
    *   **Команда:** `touch web-api-service/api/endpoints/subscription.py`
    *   **Содержимое `subscription.py`:**
        ```python
        from fastapi import APIRouter, Depends, HTTPException
        from datetime import datetime, timedelta
        from web_api_service.database.database_manager import DatabaseManager # Импортируем из web-api-service
        from api.dependencies import get_db_manager, get_current_user_id # Импортируем зависимости из web-api-service
        import logging
        import os # Для получения цены из env

        logger = logging.getLogger(__name__)

        router = APIRouter()

        @router.post("/api/v1/subscribe")
        async def subscribe_endpoint(
            db_manager: DatabaseManager = Depends(get_db_manager),
            user_id: int = Depends(get_current_user_id) # Предполагаем, что пользователь аутентифицирован
        ):
            # В реальности здесь будет интеграция с платежной системой (YooKassa, Stripe и т.п.)
            # и обработка webhook'ов для подтверждения оплаты.
            # Пока создаем подписку на 30 дней как заглушка.
            try:
                # Определяем даты
                start_date = datetime.utcnow()
                end_date = start_date + timedelta(days=30) # 30 дней
                status = "active"

                # Создать запись в БД
                subscription = await db_manager.create_subscription(user_id, status, start_date, end_date)

                # Возвращаем успешный ответ
                return {"success": True, "message": "Subscription created successfully", "subscription_id": subscription.id}

            except Exception as e:
                logger.error(f"Error in subscribe_endpoint: {e}")
                raise HTTPException(status_code=500, detail="Internal server error during subscription creation")
        ```

3.  **Обновление `require_subscription` в `api/dependencies.py`:**
    *   **Изменить функцию `require_subscription`:**
        ```python
        # ... в api/dependencies.py ...
        from datetime import datetime

        async def require_subscription(db: DatabaseManager = Depends(get_db_manager), user_id: int = Depends(get_current_user_id)) -> bool:
            subscription = await db.get_user_subscription_status(user_id)
            if not subscription or subscription.status != "active" or subscription.end_date < datetime.utcnow():
                raise HTTPException(status_code=status.HTTP_402_PAYMENT_REQUIRED, detail="Subscription required or expired")
            return True
        ```

4.  **Импорт `subscription.py` в `api/app.py`:**
    *   **Обновить `web-api-service/api/app.py`:**
        ```python
        # ... существующие импорты ...
        from api.endpoints import answer, block, plan, quiz, subjects, subscription # Добавляем subscription

        app = FastAPI(title="iXe API", ...)

        # ... существующие lifespan, middleware ...

        app.include_router(answer.router, prefix="/api/v1", tags=["answer"])
        app.include_router(block.router, prefix="/api/v1", tags=["block"])
        app.include_router(plan.router, prefix="/api/v1", tags=["plan"])
        app.include_router(quiz.router, prefix="/api/v1", tags=["quiz"])
        app.include_router(subjects.router, prefix="/api/v1", tags=["subjects"])
        app.include_router(subscription.router, tags=["subscription"]) # Добавляем роутер подписки
        ```

**Acceptance:**

*   `DatabaseManager` имеет методы для работы с `DBSubscription`.
*   Существует эндпоинт `POST /api/v1/subscribe`, который создает запись о подписке в Supabase.
*   Функция `require_subscription` проверяет статус и дату окончания подписки в Supabase.
*   Эндпоинт `POST /api/v1/subscribe` подключен к приложению.

---
*   **Задача 17 (обновленная): Реализовать `POST /api/v1/subscribe` и проверку подписки.**
    *   **Дополнительное действие:** После реализации:
        *   **Тесты (Integration):** `web-api-service/tests/integration/test_api/test_subscription_endpoint.py`
            *   Использовать `TestClient`.
            *   Мокировать `DatabaseManager`.
            *   Проверить эндпоинт `/api/v1/subscribe`.
        *   **Тесты (Unit):** `web-api-service/tests/unit/test_api/test_dependencies.py`
            *   Проверить функцию `require_subscription`: мокировать `DatabaseManager`, чтобы вернуть активную/неактивную/истёкшую подписку, проверить выброс `HTTPException`.
        *   **Acceptance:** Эндпоинт подписки и функция проверки подписки покрыты тестами.

Задача 17 (обновленная): Реализовать POST /api/v1/subscribe и проверку подписки.
Дополнительное действие (Документирование):
Обновить docstrings в subscription.py и dependencies.py.
Обновить docs/api/web-api-openapi.json.
Создать docs/business-logic/subscription-flow.md: Описать бизнес-процесс оформления и проверки подписки.
Создать docs/deployment/render-deployment.md (раздел "Переменные окружения"): Добавить CHECKER_SERVICE_URL, SEARCH_SERVICE_URL, SUPABASE_DATABASE_URL, SUBSCRIPTION_SECRET_KEY (если используется для валидации).
Acceptance (Документирование):
Соответствующие файлы содержат подробные docstrings.
OpenAPI-спецификация и/или справочник API обновлены.
Существует документация по бизнес-логике подписки.
Руководство по деплою включает переменные окружения для подписки.
