#### **Задача 0.1: Создать `common/` папку и определить общие компоненты (Детализация)**

**Цель:** Централизовать общие модели и утилиты, устранить дублирование.

**Действия:**

1.  **Создание папки `common`:**
    *   **Команда:** `mkdir -p common`

2.  **Анализ структуры проекта (`tree_output.txt`, `Pasted_Text_1762207222587.txt`, `Pasted_Text_1762248731459.txt`):**
    *   **Цель:** Определить, какие файлы/папки используются *в нескольких* сервисах и *не зависят* от тяжелых зависимостей.
    *   **Потенциальные кандидаты в `common`:**
        *   `models/`: Содержит `problem_schema.py`, `database_models.py`, `pydantic_models.py`. Эти файлы определяют структуры данных, используемые в API, скрапинге, индексации. Они *не* зависят от `playwright` или `qdrant-client`. -> **В `common`**.
        *   `utils/model_adapter.py`: Преобразует ORM в Pydantic. Используется в API и, возможно, в скрапинге. -> **В `common`**.
        *   `utils/task_id_utils.py`: Утилиты для обработки ID задач. -> **В `common`**.
        *   `utils/subject_mapping.py`: Сопоставления предметов. Используется в API, скрапинге, проверке. -> **В `common`**.
        *   `utils/task_number_inferer.py`: Определение номера задачи. Используется в скрапинге и, возможно, в API. -> **В `common`**.
        *   `services/specification.py`: Получение спецификаций. Используется в API и, возможно, в скрапинге/викторине. -> **В `common`**.
        *   `config/`: Содержит `task_number_rules.json`. -> **В `common`** (или `common/config/`).
        *   `utils/fipi_urls.py`: URL-адреса. -> **В `common`**.
        *   `utils/downloader.py`: Загрузка ассетов. Используется в скрапинге. -> **В `common`**.
        *   `processors/`: Обработка HTML. Используется в скрапинге. -> **В `common`**.
        *   `utils/metadata_extractor.py`: Извлечение метаданных. Используется в скрапинге. -> **В `common`**.
        *   `processors/page_processor.py`, `processors/block_processor.py`: Обработка страниц/блоков. Используется в скрапинге. -> **В `common`**.
        *   `utils/browser_manager.py`, `utils/answer_checker.py`: Зависит от `playwright`. -> **НЕ в `common`**.
        *   `utils/retriever.py`, `utils/vector_indexer.py`: Зависит от `qdrant-client`. -> **НЕ в `common`**.

3.  **Создание структуры `common/`:**
    *   **Команды:**
        ```bash
        mkdir -p common/models
        mkdir -p common/utils
        mkdir -p common/services
        mkdir -p common/config
        mkdir -p common/processors
        ```

4.  **Копирование файлов в `common/`:**
    *   **Команды (пример):**
        ```bash
        cp models/problem_schema.py common/models/
        cp models/database_models.py common/models/
        cp models/pydantic_models.py common/models/
        cp utils/model_adapter.py common/utils/
        cp utils/task_id_utils.py common/utils/
        cp utils/subject_mapping.py common/utils/
        cp utils/task_number_inferer.py common/utils/
        cp services/specification.py common/services/
        cp config/task_number_rules.json common/config/
        cp utils/fipi_urls.py common/utils/
        cp utils/downloader.py common/utils/
        cp processors/block_processor.py common/processors/
        cp processors/page_processor.py common/processors/
        cp utils/metadata_extractor.py common/utils/
        # ... и так далее для других кандидатов
        ```
    *   **Важно:** Копируйте *только* файлы, определенные на шаге 2 как "В `common`".

**Acceptance:**

*   Папка `common/` создана.
*   В `common/` находятся *только* файлы, не зависящие от `playwright` и `qdrant-client`.
*   Структура `common/` (models, utils, services, config, processors) отражает логическую группировку скопированных файлов.

---

Задача 0.1 (обновленная): Создать common/ папку и определить общие компоненты.
Дополнительное действие (Документирование):
Создать docs/adr/002-common-library-structure.md: Записать архитектурное решение о создании common/ библиотеки. Указать контекст (дублирование кода), рассмотренные альтернативы (копирование файлов, Git Submodules, pip install -e из подкаталога), принятое решение (создать common/ в monorepo), включенные компоненты (перечислить models/, utils/model_adapter.py, и т.д.), и ожидаемые последствия (уменьшение дублирования, сложность при обновлениях common).
Создать docs/development/common-library-guidelines.md: Руководство для разработчиков, объясняющее, что можно и чего нельзя включать в common/, как добавлять новые компоненты, как обновлять компоненты в common и тестировать изменения.
Acceptance (Документирование):
Существует ADR, описывающий структуру common/.
Существует руководство по работе с common/.

Задача 0.1 (обновленная): Создать common/ папку и определить общие компоненты.
Дополнительное действие (Инженерия требований):
Создать docs/requirements/REQ-003-Common-Library.md:
ID: REQ-003
Тип: Архитектурное требование.
Требование: "Общие компоненты (модели данных, утилиты), используемые несколькими сервисами, должны быть вынесены в централизованную библиотеку common/."
Обоснование: Устранить дублирование кода, упростить сопровождение и гарантировать согласованность между сервисами.
Критерии приемки: Компоненты, определенные как общие, находятся в common/, импортируются из common/ в сервисах, и не дублируются в каждом сервисе.
Связанные ADR: docs/adr/002-common-library-structure.md.
Acceptance (Инженерия требований):
Существует формализованное требование REQ-003 о создании common/ библиотеки.

Задача 0.1 (обновленная): Создать common/ папку и определить общие компоненты.
Дополнительное действие (Тестирование требований):
Создать tests/requirements/test_req_003_common_library.py:
Тест: test_common_components_exist_and_importable()
Цель: Проверить, что компоненты, определенные как общие, действительно находятся в common/ и могут быть импортированы из других сервисов (например, web-api-service).
Метод: Попытаться импортировать common.models.problem_schema.Problem, common.utils.model_adapter.db_problem_to_problem и т.д. из web_api_service (или через фикстуры pytest).
Связь с требованием: Покрывает REQ-003.
Acceptance (Тестирование требований):
Существует тест, проверяющий выполнение REQ-003.

*   **Задача 0.1 (обновленная): Создать `common/` папку и определить общие компоненты.**
    *   **Дополнительное действие (DevEx):**
        *   **Создать `common/pyproject.toml` (или `setup.py`/`pyproject.toml`):**
            *   **Цель:** Сделать `common/` *установленным пакетом* (например, `pip install -e common/`), чтобы избежать проблем с относительными импортами при локальной разработке. Это упрощает импорт `from common.models import ...` из `web-api-service` и других.
            *   **Содержимое (пример `setup.py` в `common/`):**
                ```python
                from setuptools import setup, find_packages

                setup(
                    name="ix-common",
                    version="0.1.0",
                    packages=find_packages(),
                    # install_requires=[], # Если common зависит от чего-то дополнительно
                )
                ```
        *   **Обновить `Makefile`:**
            *   **Добавить команду:** `install-common: pip install -e common/`.
    *   **Acceptance (DevEx):**
        *   `common/` можно установить как пакет.
        *   Импорты из `common` работают корректно в других сервисах при локальной разработке.

        *   **Задача 0.1 (обновленная): Создать `common/` папку и определить общие компоненты.**
    *   **Дополнительное действие (DevOps/SRE):**
        *   **Обновить `Dockerfile` (для каждого сервиса, использующего `common`):**
            *   **Убедиться**, что `Dockerfile` корректно *копирует* папку `common/` в контейнер и *устанавливает* её как пакет или *настраивает* `PYTHONPATH`, чтобы импорты из `common` работали. (Это уже частично отражено в примере `Dockerfile.web` выше).
    *   **Acceptance (DevOps/SRE):**
        *   Docker-образы сервисов, использующих `common`, корректно включают и используют `common/`.

*   **Задача 0.1 (обновленная): Создать `common/` папку и определить общие компоненты.**
    *   **Дополнительное действие (DevSecOps):**
        *   **Обновить `common/` (или `common/pyproject.toml`/`setup.py`), если используется как пакет:**
            *   Убедиться, что `common` *не* содержит чувствительных данных или уязвимых функций.
        *   **Запустить `bandit` или `semgrep` на `common/`:**
            *   Убедиться, что общие компоненты безопасны.
    *   **Acceptance (DevSecOps):**
        *   Компоненты в `common/` прошли базовую проверку на безопасность.        

Задача 0.1 (обновленная): Создать common/ папку и определить общие компоненты.
Дополнительное действие (Экспертная оптимизация):
Проанализировать common/models/ и common/utils/:
Цель: Убедиться, что каждый компонент в common действительно используется более чем в одном сервисе и не содержит логики, специфичной для одного сервиса (например, FIPIAnswerChecker в common - плохо).
Действие: Провести аудит, переместить специфичные компоненты обратно в соответствующие сервисы.
Создать common/utils/memory_efficient_adapters.py (новый файл, если нужно):
Цель: Предоставить эффективные функции преобразования данных (например, db_problem_to_problem) с учетом производительности и потребления памяти.
Пример: Использовать __slots__ в Pydantic-моделях (если возможно без потери гибкости), dataclasses вместо dict для промежуточных представлений, генераторы (yield) для обработки списков задач.        