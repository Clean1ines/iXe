Хорошо, продолжим детализацию плана рефакторинга, следуя уже установленной структуре и целям.

---

### **Фаза 2: Переход на Supabase и обновление `web-api-service` (Фокус: Центральный компонент, использование `common`)**

**Цель Фазы 2:**

1.  Создать обновленный `DatabaseManager` для `web-api-service`, который подключается к Supabase PostgreSQL.
2.  Создать HTTP-клиенты (`checker_client`, `search_client`) для взаимодействия с новыми сервисами.
3.  Обновить `AnswerService` и `QuizService` для использования новых компонентов (`DatabaseManager`, `checker_client`, `search_client`).
4.  Обновить `api/dependencies.py` для инъекции новых зависимостей.
5.  Обновить эндпоинты (`answer.py`, `quiz.py`, `block.py`) для использования обновленных сервисов.
6.  Убедиться, что `web-api-service` использует компоненты из `common`.

---

#### **Задача 3 (обновленная): Создать `database_manager.py` для Supabase *внутри* `web-api-service`, но использовать модели из `common` (Детализация)**

**Цель:** Создать `database/database_manager.py` для `web-api-service`, который подключается к Supabase PostgreSQL и использует модели из `common`.

**Действия:**

1.  **Создание структуры `web-api-service`:**
    *   **Команда:** `mkdir -p web-api-service/{api,database,services,utils,models,config}`

2.  **Создание `database/database_manager.py` для `web-api-service`:**
    *   **Команда:** `touch web-api-service/database/database_manager.py`
    *   **Содержимое `database_manager.py`:**
        ```python
        import logging
        from typing import List, Optional
        from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
        from sqlalchemy.orm import sessionmaker
        from sqlalchemy import select, update, insert, delete
        from sqlalchemy.exc import SQLAlchemyError
        from common.models.database_models import DBUser, DBAnswer, DBTaskStatus, DBQuizSession, DBSkillGraph # Импортируем из common
        from common.models.pydantic_models import Problem, User, Answer, TaskStatus, QuizSession, SkillGraph # Импортируем из common
        from common.utils.model_adapter import db_problem_to_problem # Импортируем из common, если нужно

        logger = logging.getLogger(__name__)

        class DatabaseManager:
            def __init__(self, database_url: str):
                self.engine = create_async_engine(database_url)
                self.async_session = sessionmaker(self.engine, class_=AsyncSession, expire_on_commit=False)

            async def get_user(self, user_id: int) -> Optional[User]:
                async with self.async_session() as session:
                    try:
                        result = await session.execute(select(DBUser).where(DBUser.id == user_id))
                        db_user = result.scalar_one_or_none()
                        if db_user:
                            # Преобразовать DBUser в Pydantic User (если нужно, создайте адаптер)
                            return User(id=db_user.id, email=db_user.email, ...) # Заполните атрибуты
                        return None
                    except SQLAlchemyError as e:
                        logger.error(f"Error fetching user {user_id}: {e}")
                        raise # Или обработайте как-то по-другому

            async def create_user(self, email: str) -> User:
                async with self.async_session() as session:
                    try:
                        db_user = DBUser(email=email)
                        session.add(db_user)
                        await session.commit()
                        await session.refresh(db_user)
                        # Преобразовать DBUser в Pydantic User
                        return User(id=db_user.id, email=db_user.email, ...) # Заполните атрибуты
                    except SQLAlchemyError as e:
                        logger.error(f"Error creating user with email {email}: {e}")
                        await session.rollback()
                        raise

            async def save_answer(self, user_id: int, problem_id: str, user_answer: str, is_correct: bool) -> None:
                async with self.async_session() as session:
                    try:
                        # Проверить, существует ли уже ответ
                        result = await session.execute(
                            select(DBAnswer).where(DBAnswer.user_id == user_id, DBAnswer.problem_id == problem_id)
                        )
                        db_answer = result.scalar_one_or_none()

                        if db_answer:
                            # Обновить существующий ответ
                            await session.execute(
                                update(DBAnswer)
                                .where(DBAnswer.id == db_answer.id)
                                .values(user_answer=user_answer, is_correct=is_correct)
                            )
                        else:
                            # Создать новый ответ
                            db_answer = DBAnswer(user_id=user_id, problem_id=problem_id, user_answer=user_answer, is_correct=is_correct)
                            session.add(db_answer)

                        await session.commit()
                    except SQLAlchemyError as e:
                        logger.error(f"Error saving answer for user {user_id}, problem {problem_id}: {e}")
                        await session.rollback()
                        raise

            async def get_answer_and_status(self, user_id: int, problem_id: str) -> Optional[Answer]:
                async with self.async_session() as session:
                    try:
                        result = await session.execute(
                            select(DBAnswer, DBTaskStatus)
                            .where(DBAnswer.user_id == user_id, DBAnswer.problem_id == problem_id)
                            .outerjoin(DBTaskStatus, (DBTaskStatus.user_id == user_id) & (DBTaskStatus.problem_id == problem_id))
                        )
                        answer_row, status_row = result.first()
                        if answer_row:
                            # Преобразовать DBAnswer и DBTaskStatus в Pydantic Answer
                            return Answer(user_id=answer_row.user_id, problem_id=answer_row.problem_id, user_answer=answer_row.user_answer, is_correct=answer_row.is_correct, status=status_row.status if status_row else None) # Заполните атрибуты
                        return None
                    except SQLAlchemyError as e:
                        logger.error(f"Error fetching answer for user {user_id}, problem {problem_id}: {e}")
                        raise

            async def update_task_status(self, user_id: int, problem_id: str, status: str) -> None:
                async with self.async_session() as session:
                    try:
                        # Проверить, существует ли уже статус
                        result = await session.execute(
                            select(DBTaskStatus).where(DBTaskStatus.user_id == user_id, DBTaskStatus.problem_id == problem_id)
                        )
                        db_status = result.scalar_one_or_none()

                        if db_status:
                            # Обновить существующий статус
                            await session.execute(
                                update(DBTaskStatus)
                                .where(DBTaskStatus.id == db_status.id)
                                .values(status=status)
                            )
                        else:
                            # Создать новый статус
                            db_status = DBTaskStatus(user_id=user_id, problem_id=problem_id, status=status)
                            session.add(db_status)

                        await session.commit()
                    except SQLAlchemyError as e:
                        logger.error(f"Error updating task status for user {user_id}, problem {problem_id}: {e}")
                        await session.rollback()
                        raise

            # ... Добавьте другие методы: get_quiz_session, create_quiz_session, update_quiz_session, get_user_skill_graph, update_user_skill_graph, get_problems_by_ids, get_all_problems и т.д. ...
            # Все операции должны использовать ORM-модели из common.models.database_models

        ```
    *   **Примечание:** Эта версия `DatabaseManager` *не* содержит логики для задач (`problems`), так как она будет храниться в Supabase и, возможно, управляться `scraper-service` и `indexer-service`. `web-api-service` будет *читать* задачи из Supabase, но *не сохранять* новые задачи (кроме, возможно, пользовательских данных, связанных с задачами, как ответы и статусы).

3.  **Копирование `common` в `web-api-service` (для Dockerfile):**
    *   **Команда:** `cp -r common web-api-service/` (или копируйте в `Dockerfile` во время сборки, как было описано в Фазе 0 для `Dockerfile.web`).

**Acceptance:**

*   Файл `web-api-service/database/database_manager.py` создан.
*   Он использует `sqlalchemy` с `asyncpg` для подключения к PostgreSQL (Supabase).
*   Он импортирует ORM-модели (`DBUser`, `DBAnswer`, `DBTaskStatus`, `DBQuizSession`, `DBSkillGraph`) и Pydantic-схемы (`User`, `Answer`, `TaskStatus`, `QuizSession`, `SkillGraph`) из `common.models`.
*   Он импортирует `db_problem_to_problem` из `common.utils.model_adapter` (если используется).
*   Реализованы методы для работы с пользовательскими данными (CRUD для `DBAnswer`, `DBTaskStatus`, `DBQuizSession`, `DBSkillGraph`, `DBUser`).

---