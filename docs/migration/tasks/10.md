### **Фаза 2: Переход на Supabase и обновление `web-api-service` (Фокус: Центральный компонент, использование `common`) (Продолжение)**

---

#### **Задача 9 (обновленная): Обновить `services/quiz_service.py`, использовать `common`. (Детализация)**

**Цель:** Обновить `QuizService` для использования `DatabaseManager` (Supabase), `search_client` и `common`.

**Действия:**

1.  **Копирование `services/quiz_service.py` в `web-api-service`:**
    *   **Команда:** `cp services/quiz_service.py web-api-service/services/`
    *   **Обновление импортов в `quiz_service.py`:**
        ```python
        # Было (или что-то подобное):
        # from utils.database_manager import DatabaseManager
        # from utils.retriever import QdrantProblemRetriever # Если использовалось напрямую
        # from services.specification import SpecificationService
        # from utils.skill_graph import InMemorySkillGraph
        # from utils.task_number_inferer import TaskNumberInferer
        # from models.pydantic_models import Problem, QuizSession, ...

        # Стало:
        from web_api_service.database.database_manager import DatabaseManager # Или как у вас будет импортироваться
        from web_api_service.clients.search_client import SearchClient # Или как у вас будет импортироваться, если выносите в отдельный сервис
        # from common.clients.problem_retriever import QdrantProblemRetriever # Если QdrantProblemRetriever и его зависимости (qdrant-client) остаются в web-api (не рекомендуется)
        from common.services.specification import SpecificationService # Импортируем из common
        from common.utils.skill_graph import InMemorySkillGraph # Импортируем из common
        from common.utils.task_number_inferer import TaskNumberInferer # Импортируем из common
        from common.models.pydantic_models import Problem, QuizSession, StartQuizRequest, StartQuizResponse # Импортируем из common
        # ... другие импорты из common, если используются
        import logging

        logger = logging.getLogger(__name__)

        class QuizService:
            def __init__(self, db_manager: DatabaseManager, search_client: SearchClient, spec_service: SpecificationService, skill_graph: InMemorySkillGraph, task_inferer: TaskNumberInferer):
                self.db_manager = db_manager
                self.search_client = search_client # Или self.problem_retriever, если используете Qdrant напрямую
                self.spec_service = spec_service
                self.skill_graph = skill_graph
                self.task_inferer = task_inferer
                # ... другие зависимости

            async def start_quiz(self, user_id: int, request: StartQuizRequest) -> StartQuizResponse:
                # 1. Получить текущий прогресс пользователя (из Supabase через db_manager)
                user_skill_graph_data = await self.db_manager.get_user_skill_graph(user_id)
                self.skill_graph.load_from_dict(user_skill_graph_data) # Загрузить в инстанс

                # 2. Определить стратегию/план (из spec_service)
                # specification = self.spec_service.get_specification(request.subject, request.year) # Пример

                # 3. Выбрать задачи на основе прогресса, плана, стратегии и, возможно, похожих задач (из search_client)
                # selected_problem_ids = await self._select_problems(user_skill_graph, specification, strategy) # Реализуйте логику
                # Используйте self.search_client.retrieve_similar_problems если нужно
                # similar_problems = await self.search_client.retrieve_similar_problems(failed_problem_id)

                # 4. Создать сессию викторины (в Supabase через db_manager или в памяти/Redis)
                # quiz_session_id = await self.db_manager.create_quiz_session(user_id, request.subject)
                # current_state = {"problem_ids": selected_problem_ids, "current_index": 0, "answers": []}
                # await self.db_manager.update_quiz_session(quiz_session_id, current_state)

                # 5. Сформировать и вернуть ответ
                # return StartQuizResponse(session_id=quiz_session_id, problems=selected_problems, ...) # Заполните атрибуты
                pass # Заглушка

            async def get_next_task(self, session_id: str) -> Problem:
                # 1. Получить состояние сессии (из Supabase или памяти/Redis)
                # session_data = await self.db_manager.get_quiz_session(session_id)
                # current_index = session_data.get("current_index", 0)
                # problem_id = session_data["problem_ids"][current_index]

                # 2. Получить задачу (из Supabase через db_manager)
                # problem = await self.db_manager.get_problem_by_id(problem_id)

                # 3. Вернуть задачу
                # return problem
                pass # Заглушка

            # ... другие методы ...

            async def _select_problems(self, user_skill_graph, specification, strategy):
                # Реализуйте сложную логику выбора задач
                # Используйте user_skill_graph, specification, strategy, и возможно self.search_client
                pass # Заглушка
        ```

2.  **Копирование `common` в `web-api-service` (если не копируется в Dockerfile):**
    *   **Команда:** `cp -r common web-api-service/`

**Acceptance:**

*   Файл `web-api-service/services/quiz_service.py` обновлен.
*   Он импортирует `DatabaseManager` из `web-api-service/database/database_manager.py`.
*   Он импортирует `SearchClient` из `web-api-service/clients/search_client.py` (или `QdrantProblemRetriever` из `common`, если используется напрямую).
*   Он импортирует `SpecificationService`, `InMemorySkillGraph`, `TaskNumberInferer` из `common`.
*   Он импортирует `Problem`, `QuizSession`, `StartQuizRequest`, `StartQuizResponse` из `common.models.pydantic_models`.
*   Его методы используют `self.db_manager`, `self.search_client`, `self.spec_service`, `self.skill_graph`, `self.task_inferer`.

---

#### **Задача 6 (обновленная): Обновить `api/dependencies.py`, использовать `common`. (Детализация)**

**Цель:** Обновить зависимости API для инъекции новых сервисов (`DatabaseManager`, `CheckerClient`, `AnswerService`, `QuizService` и т.д.).

**Действия:**

1.  **Копирование `api/dependencies.py` в `web-api-service`:**
    *   **Команда:** `cp api/dependencies.py web-api-service/api/`
    *   **Обновление импортов в `api/dependencies.py`:**
        ```python
        # Было (или что-то подобное):
        # from utils.database_manager import DatabaseManager
        # from services.answer_service import AnswerService
        # from services.quiz_service import QuizService
        # from utils.answer_checker import FIPIAnswerChecker
        # from utils.browser_manager import BrowserManager
        # from utils.retriever import QdrantProblemRetriever # Если использовалось напрямую
        # from clients.checker_client import CheckerClient # Если уже был
        # from clients.search_client import SearchClient # Если уже был
        # from services.specification import SpecificationService
        # from utils.skill_graph import InMemorySkillGraph
        # from utils.task_number_inferer import TaskNumberInferer
        # from models.pydantic_models import ... # Если использовались схемы

        # Стало:
        from fastapi import Depends, HTTPException, status
        from web_api_service.database.database_manager import DatabaseManager # Импортируем из web-api-service
        from web_api_service.services.answer_service import AnswerService # Импортируем из web-api-service
        from web_api_service.services.quiz_service import QuizService # Импортируем из web-api-service
        from web_api_service.clients.checker_client import CheckerClient # Импортируем из web-api-service
        from web_api_service.clients.search_client import SearchClient # Импортируем из web-api-service
        # from common.clients.problem_retriever import QdrantProblemRetriever # Если QdrantProblemRetriever и его зависимости (qdrant-client) остаются в web-api (не рекомендуется)
        from common.services.specification import SpecificationService # Импортируем из common
        from common.utils.skill_graph import InMemorySkillGraph # Импортируем из common
        from common.utils.task_number_inferer import TaskNumberInferer # Импортируем из common
        from common.models.pydantic_models import User # Импортируем схемы из common, если используются
        # ... другие импорты из common и web-api-service
        import os
        import logging

        logger = logging.getLogger(__name__)

        # Зависимость для получения DatabaseManager
        async def get_db_manager() -> DatabaseManager:
            # Используем URL из переменной окружения
            database_url = os.getenv("SUPABASE_DATABASE_URL") # Или DATABASE_URL
            if not database_url:
                raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database URL not configured")
            return DatabaseManager(database_url)

        # Зависимость для получения CheckerClient
        async def get_checker_client() -> CheckerClient:
            base_url = os.getenv("CHECKER_SERVICE_URL")
            if not base_url:
                raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Checker Service URL not configured")
            return CheckerClient(base_url=base_url)

        # Зависимость для получения SearchClient
        async def get_search_client() -> SearchClient:
            base_url = os.getenv("SEARCH_SERVICE_URL") # или QDRANT_URL, если прямое подключение
            if not base_url:
                raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Search Service URL not configured")
            return SearchClient(base_url=base_url)

        # Зависимость для получения AnswerService
        async def get_answer_service(
            db: DatabaseManager = Depends(get_db_manager),
            checker_client: CheckerClient = Depends(get_checker_client)
        ) -> AnswerService:
            return AnswerService(db_manager=db, checker_client=checker_client)

        # Зависимость для получения QuizService
        async def get_quiz_service(
            db: DatabaseManager = Depends(get_db_manager),
            search_client: SearchClient = Depends(get_search_client), # или QdrantProblemRetriever
            spec_service: SpecificationService = Depends(get_spec_service), # Предполагаем, что get_spec_service определена
            skill_graph: InMemorySkillGraph = Depends(get_skill_graph), # Предполагаем, что get_skill_graph определена
            task_inferer: TaskNumberInferer = Depends(get_task_number_inferer) # Предполагаем, что get_task_number_inferer определена
        ) -> QuizService:
            return QuizService(
                db_manager=db,
                search_client=search_client, # или problem_retriever
                spec_service=spec_service,
                skill_graph=skill_graph,
                task_inferer=task_inferer
            )

        # ... другие зависимости ...

        # Пример зависимостей для common компонентов (если нужно инжектировать их напрямую)
        def get_spec_service() -> SpecificationService:
            # subject_mapping = get_subject_mapping() # Если нужно
            # specification_path = os.getenv("SPECIFICATION_PATH", "config/specification.json") # Пример
            # return SpecificationService.from_file(specification_path)
            pass # Реализуйте

        def get_skill_graph() -> InMemorySkillGraph:
            # Возвращает новый инстанс или из пула, в зависимости от логики
            return InMemorySkillGraph()

        def get_task_number_inferer() -> TaskNumberInferer:
            rules_path = os.getenv("TASK_NUMBER_RULES_PATH", "config/task_number_rules.json") # Пример
            return TaskNumberInferer.from_file(rules_path)

        # Зависимость для проверки подписки (из задачи 17)
        async def require_subscription(db: DatabaseManager = Depends(get_db_manager), user_id: int = Depends(get_current_user_id)) -> bool:
            # subscription = await db.get_user_subscription_status(user_id) # Предполагаем, что метод есть
            # if not subscription or subscription.status != "active":
            #    raise HTTPException(status_code=status.HTTP_402_PAYMENT_REQUIRED, detail="Subscription required")
            # return True
            pass # Реализуйте

        # get_current_user_id: Реализуйте аутентификацию JWT/сессии
        async def get_current_user_id() -> int:
            # Извлеките user_id из токена/сессии
            # return user_id
            pass # Заглушка
        ```

2.  **Копирование `common` в `web-api-service` (если не копируется в Dockerfile):**
    *   **Команда:** `cp -r common web-api-service/`

**Acceptance:**

*   Файл `web-api-service/api/dependencies.py` обновлен.
*   Он импортирует `DatabaseManager`, `AnswerService`, `QuizService`, `CheckerClient`, `SearchClient` из `web-api-service`.
*   Он импортирует `SpecificationService`, `InMemorySkillGraph`, `TaskNumberInferer` из `common`.
*   Он определяет зависимости `get_db_manager`, `get_checker_client`, `get_search_client`, `get_answer_service`, `get_quiz_service`, `get_spec_service`, `get_skill_graph`, `get_task_number_inferer`.
*   Зависимости корректно инжектируют экземпляры соответствующих классов, используя другие зависимости.

---




