#### **Задача 4: Создать `clients/checker_client.py`. (Детализация)**

**Цель:** Создать HTTP-клиент для вызова `checker-service` из `web-api-service`.

**Действия:**

1.  **Создание `clients/checker_client.py` внутри `web-api-service`:**
    *   **Команда:** `touch web-api-service/clients/checker_client.py`
    *   **Содержимое `checker_client.py`:**
        ```python
        import httpx
        import logging
        from typing import Dict, Any
        from common.models.pydantic_models import CheckAnswerRequest, CheckAnswerResponse # Импортируем из common

        logger = logging.getLogger(__name__)

        class CheckerClient:
            def __init__(self, base_url: str, timeout: int = 30):
                self.base_url = base_url.rstrip('/')
                self.timeout = timeout
                self.client = httpx.AsyncClient(timeout=timeout)

            async def check_answer(self, task_id: str, user_answer: str, subject: str) -> CheckAnswerResponse:
                url = f"{self.base_url}/check_answer" # Предполагаемый эндпоинт в checker-service
                payload = CheckAnswerRequest(task_id=task_id, user_answer=user_answer, subject=subject).dict() # Используем Pydantic модель

                try:
                    response = await self.client.post(url, json=payload)
                    response.raise_for_status() # Возбуждает исключение для 4xx/5xx статусов
                    result_data = response.json()
                    # Преобразовать ответ в Pydantic-модель
                    return CheckAnswerResponse(**result_data)
                except httpx.HTTPStatusError as e:
                    logger.error(f"HTTP error from checker-service: {e.response.status_code} - {e.response.text}")
                    # Здесь можно вернуть заглушку или поднять кастомное исключение
                    raise # или return CheckAnswerResponse(is_correct=False, feedback="Error checking answer")
                except httpx.RequestError as e:
                    logger.error(f"Request error to checker-service: {e}")
                    raise # или return CheckAnswerResponse(is_correct=False, feedback="Connection error")
                except Exception as e:
                    logger.error(f"Unexpected error calling checker-service: {e}")
                    raise # или return CheckAnswerResponse(is_correct=False, feedback="Internal error")

            async def close(self):
                await self.client.aclose()

        ```
    *   **Примечание:** `CheckAnswerRequest` и `CheckAnswerResponse` должны быть определены в `common/models/pydantic_models.py`.

2.  **Копирование `common` в `web-api-service` (если не копируется в Dockerfile):**
    *   **Команда:** `cp -r common web-api-service/`

**Acceptance:**

*   Файл `web-api-service/clients/checker_client.py` создан.
*   Он использует `httpx.AsyncClient`.
*   Он импортирует `CheckAnswerRequest`, `CheckAnswerResponse` из `common.models.pydantic_models`.
*   Он имеет метод `check_answer`, который делает `POST` запрос к `checker-service` и возвращает `CheckAnswerResponse`.

*   **Задача 4 (обновленная): Создать `clients/checker_client.py`.**
    *   **Дополнительное действие:** После создания `checker_client.py`:
        *   **Тесты (Unit):** `web-api-service/tests/unit/test_clients/test_checker_client.py`
            *   Мокировать `httpx.AsyncClient`.
            *   Проверить, что `check_answer` формирует правильный `POST` запрос и корректно обрабатывает успешный ответ и ошибки (4xx, 5xx, `RequestError`).
        *   **Acceptance:** `checker_client.py` покрыт юнит-тестами с мокированием HTTP-клиента.

*   **Задача 8 (обновленная): Создать `clients/search_client.py`.**
    *   **Дополнительное действие:** После создания `search_client.py`:
        *   **Тесты (Unit):** `web-api-service/tests/unit/test_clients/test_search_client.py`
            *   Мокировать `httpx.AsyncClient`.
            *   Проверить, что `retrieve_similar_problems` формирует правильный `POST` запрос и корректно обрабатывает успешный ответ и ошибки.
        *   **Acceptance:** `search_client.py` покрыт юнит-тестами с мокированием HTTP-клиента.




