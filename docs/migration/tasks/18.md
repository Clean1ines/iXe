

#### **Задача 18: Финальное тестирование и деплой `web-api-service`. (Детализация)**

**Цель:** Убедиться, что `web-api-service` развертывается на Render Free без `Out of memory` и работает с новыми сервисами.

**Действия:**

1.  **Финальная проверка `Dockerfile.web` (или `Dockerfile` в `web-api-service`):**
    *   Убедитесь, что `Dockerfile` использует `requirements_web.txt`.
    *   Убедитесь, что `Dockerfile` использует многоступенчатую сборку.
    *   Убедитесь, что `Dockerfile` включает `RUN pip cache purge` в `builder` стадии.
    *   Убедитесь, что `Dockerfile` копирует `common/` и устанавливает его как пакет или настраивает `PYTHONPATH`.
    *   Убедитесь, что `playwright install` *отсутствует* в `runtime` стадии.
    *   Убедитесь, что `CMD` запускает `uvicorn` с правильной точкой входа (`web-api-service.run:app` или `web-api-service.api.app:app`, в зависимости от структуры).

2.  **Финальная проверка `requirements_web.txt`:**
    *   Убедитесь, что `playwright`, `qdrant-client`, `beautifulsoup4`, `lxml`, `aiofiles`, `requests-html`, `selenium` *отсутствуют*.

3.  **Локальное тестирование (опционально, но рекомендуется):**
    *   Соберите Docker-образ: `docker build -f web-api-service/Dockerfile.web -t ix-web-api-test .`
    *   Запустите контейнер: `docker run -p 10000:10000 --env-file .env ix-web-api-test`
    *   Проверьте доступность эндпоинтов через `curl` или Postman.

4.  **Деплой на Render:**
    *   Создайте новый Web Service на Render, используя репозиторий `web-api-service`.
    *   Укажите `Dockerfile.web` как путь к Dockerfile.
    *   Установите переменные окружения: `SUPABASE_DATABASE_URL`, `CHECKER_SERVICE_URL`, `SEARCH_SERVICE_URL`, `PORT` (10000).
    *   Запустите деплой.

5.  **Мониторинг деплоя и логов на Render:**
    *   Проверьте вкладку **Events** -> **Deploy Logs** на Render Dashboard.
    *   Ищите ошибки `Out of memory`, `pip install` тяжелых пакетов, `playwright install` в runtime.
    *   После деплоя перейдите на вкладку **Logs**.
    *   Ищите ошибки `ImportError`, `SQLAlchemyError`, `httpx.RequestError` (ошибки связи с другими сервисами).
    *   Проверьте, запускается ли `uvicorn` и слушает ли порт `PORT`.

**Acceptance:**

*   `Dockerfile.web` корректен.
*   `requirements_web.txt` не содержит тяжелых зависимостей.
*   Деплой на Render проходит успешно.
*   Нет ошибки `Out of memory` при запуске.
*   Основной функционал (получение задач, проверка ответов через `checker-service`, старт викторины через `quiz-service`) работает корректно (требует тестирования API).
*   Доступ к функциям ограничен подпиской (проверка `require_subscription`).

---

**Итог всего плана:**

Этот детализированный план охватывает ключевые аспекты перехода от монолитного приложения к архитектуре микросервисов с использованием `common` библиотеки, изоляцией тяжелых зависимостей (`playwright`, `qdrant-client`) и переходом на внешнюю БД (Supabase). Он направлен на решение проблемы `Out of memory` на Render Free для веб-API и подготовку приложения к монетизации. Реализация этого плана требует тщательного выполнения каждого шага, особенно обновления импортов и настройки `Dockerfile`.

*   **Задача 18 (обновленная): Финальное тестирование и деплой `web-api-service`.**
    *   **Дополнительное действие:** Перед деплоем:
        *   **Запуск всех тестов:** `pytest web-api-service/tests/unit/` и `pytest web-api-service/tests/integration/`.
        *   **Покрытие кода:** `pytest --cov=web_api_service --cov=common web-api-service/tests/unit/ web-api-service/tests/integration/`. Убедиться, что покрытие соответствует целевому уровню.
        *   **E2E тесты (опционально, но рекомендуется):** Создать `tests/e2e/test_user_journey.py` (в корне или в `web-api-service`).
            *   Использовать `TestClient` или инструмент вроде `Playwright`/`Selenium`.
            *   Имитировать пользовательский сценарий: регистрация -> выбор предмета -> начало викторины -> решение задачи -> проверка ответа -> получение обратной связи -> проверка прогресса.
            *   Для этого потребуется запуск *всех* сервисов (или их моков) в изолированной среде (например, через `docker-compose` для тестов).
        *   **Acceptance:** Все юнит- и интеграционные тесты для `web-api-service` проходят. Покрытие кода на удовлетворительном уровне. E2E тесты (если реализованы) проходят.

---

### **Интеграция в CI/CD:**

*   **`.github/workflows/test.yml` (или аналог):**
    *   **Шаг 1:** Установка зависимостей (`pip install -r requirements_web.txt`, `pip install -r dev-requirements.txt`).
    *   **Шаг 2:** Запуск `pytest web-api-service/tests/unit/`.
    *   **Шаг 3:** Запуск `pytest web-api-service/tests/integration/`.
    *   **Шаг 4:** (Опционально) Запуск `pytest --cov=web_api_service --cov=common ...` и отправка отчета в сервис анализа (например, Codecov).
    *   **Шаг 5:** (Опционально) Запуск E2E тестов (требует запуска всех зависимых сервисов, например, через `docker-compose up --build` в CI).
    *   **Условие:** Деплой на Render *не должен* происходить, если *любой* из тестов (юнит, интеграционный, E2E) *падает*.

Задача 18 (обновленная): Финальное тестирование и деплой web-api-service.
Дополнительное действие (Документирование):
Обновить README.md (корень проекта): Обновить описание проекта, архитектуры (микросервисы, common, Supabase), инструкции по запуску/тестированию/деплою, ссылки на основные документы (docs/).
Создать docs/operations/troubleshooting.md: Собрать часто задаваемые вопросы и решения проблем, возникающих при разработке/тестировании/деплое (включая Out of memory, ошибки подключения к сервисам, ошибки валидации Pydantic).
Acceptance (Документирование):
Главный README.md отражает новую архитектуру и процесс.
Существует руководство по устранению неполадок.

Задача 18 (обновленная): Финальное тестирование и деплой web-api-service.
Дополнительное действие (Инженерия требований):
Создать docs/requirements/SRS.md (Software Requirements Specification - кратко):
Сборка: Собрать все REQ-*.md файлы в общий документ или ссылаться на них из центрального SRS.
Трассировка: Убедиться, что каждое требование покрыто тестами (например, REQ-002 -> тест на Out of memory при деплое).
Валидация: Убедиться, что реализация соответствует всем сформулированным требованиям.
Acceptance (Инженерия требований):
Существует централизованный обзор требований (SRS или ссылки на REQ-*.md).
Требования трассированы к тестам и реализации.

Задача 18 (обновленная): Финальное тестирование и деплой web-api-service.
Дополнительное действие (Тестирование требований):
Создать docs/requirements/traceability_matrix.csv (или .md):
Содержание: Таблица, сопоставляющая ID требований (REQ-001, REQ-002 и т.д.) с тестами (например, tests/requirements/test_req_001_dependency_separation.py::test_web_api_does_not_contain_heavy_deps), ADR, документами.
Цель: Обеспечить видимость и трассируемость требований к тестам и реализации.
Запуск тестов требований: Добавить запуск pytest tests/requirements/ в CI/CD pipeline.
Acceptance (Тестирование требований):
Существует матрица трассируемости требований к тестам.
Тесты требований запускаются в CI/CD и проходят успешно.

*   **Задача 18 (обновленная): Финальное тестирование и деплой `web-api-service`.**
    *   **Дополнительное действие (DevEx):**
        *   **Обновить `README.md` (корень):**
            *   **Добавить раздел "CI/CD Overview":** Краткое описание того, что делает CI/CD (запускает тесты, проверяет форматирование, деплоит).
            *   **Добавить раздел "Troubleshooting Deploys":** Ссылки на документы Render по устранению неполадок (как в предоставленной веб-странице), советы по чтению логов.
        *   **Обновить `Makefile`:**
            *   **Добавить команду:** `logs-web-api` (например, `ssh` команда или вызов Render CLI для просмотра логов).
    *   **Acceptance (DevEx):**
        *   Главный `README.md` содержит обзор CI/CD и советы по устранению неполадок.
        *   Есть удобная команда для просмотра логов деплоя (если возможно через `Makefile`).

*   **Задача 18 (обновленная): Финальное тестирование и деплой `web-api-service`.**
    *   **Дополнительное действие (DevOps/SRE):**
        *   **Создать `.github/workflows/ci_cd.yml` (или аналог для вашей платформы CI/CD):**
            *   **Цель:** Автоматизировать тестирование, сборку Docker-образов и деплой.
            *   **Содержимое (пример для GitHub Actions):**
                ```yaml
                name: CI/CD Pipeline

                on:
                  push:
                    branches: [ main, develop ] # Триггер на пуши в определенные ветки
                  pull_request:
                    branches: [ main ]

                jobs:
                  test:
                    runs-on: ubuntu-latest
                    steps:
                      - uses: actions/checkout@v4
                      - name: Set up Python
                        uses: actions/setup-python@v4
                        with:
                          python-version: '3.11'
                      - name: Install dependencies
                        run: |
                          python -m pip install --upgrade pip
                          pip install -r requirements.txt -r dev-requirements.txt
                      - name: Run unit tests
                        run: pytest tests/unit/
                      - name: Run integration tests
                        run: pytest tests/integration/
                      - name: Run linters (optional)
                        run: |
                          black --check .
                          isort --check-only .
                          flake8 .
                          mypy .

                  build-and-push-web-api:
                    needs: test # Запускается только если тесты прошли
                    runs-on: ubuntu-latest
                    permissions:
                      contents: read
                      packages: write # Для пуша в GitHub Container Registry
                    steps:
                      - uses: actions/checkout@v4
                      - name: Login to GitHub Container Registry
                        uses: docker/login-action@v3
                        with:
                          registry: ghcr.io
                          username: ${{ github.actor }}
                          password: ${{ secrets.GITHUB_TOKEN }}
                      - name: Build and push web-api Docker image
                        uses: docker/build-push-action@v5
                        with:
                          context: .
                          file: web-api-service/Dockerfile.web
                          push: true
                          tags: ghcr.io/${{ github.repository }}/web-api:latest,ghcr.io/${{ github.repository }}/web-api:${{ github.sha }}

                  # ... аналогично для scraper-service, checker-service и т.д. ...

                  deploy-web-api-to-render:
                    needs: build-and-push-web-api # Запускается после успешной сборки
                    runs-on: ubuntu-latest
                    if: github.ref == 'refs/heads/main' # Только для ветки main
                    steps:
                      - name: Deploy to Render
                        run: |
                          # Используйте Render CLI или вызовите Render API для триггера деплоя
                          # Пример (требует настройки Render CLI и токена):
                          # render deploy --serviceId <your-service-id> --notify
                          # Или триггерите через вебхук Render
                          echo "Trigger Render deploy for web-api-service"
                          # curl -X POST https://api.render.com/v1/services/<service-id>/deployments \
                          #   -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
                          #   -H "Content-Type: application/json" \
                          #   -d '{"clearCache": "clear"}'
                          # (Реализация зависит от вашей настройки Render)
                ```
        *   **Обновить `README.md` (корень):**
            *   **Добавить раздел "CI/CD Pipeline":** Краткое описание процесса CI/CD, ссылка на файл конфигурации (`.github/workflows/ci_cd.yml`).
            *   **Добавить раздел "Deployment":** Как деплоить вручную (Render Dashboard), как триггерить деплой через CLI/API (если настроено), важные переменные окружения.
        *   **Обновить `docs/deployment/render-deployment.md`:**
            *   **Добавить раздел "Health Checks":** Как настроить health check endpoint (например, `/`) на Render для `web-api-service`.
            *   **Добавить раздел "Monitoring & Logging":** Как просматривать логи на Render Dashboard, важные шаблоны поиска ошибок (`Out of memory`, `500 Internal Server Error`, `Connection refused` к зависимостям).
            *   **Добавить раздел "Scaling & Resources":** Рекомендации по типу инстанса (Free, Starter, Professional) на Render в зависимости от ожидаемой нагрузки и потребления ресурсов. Как мониторить использование ресурсов.
    *   **Acceptance (DevOps/SRE):**
        *   Существует конфигурация CI/CD (например, `.github/workflows/ci_cd.yml`), автоматизирующая тестирование и деплой.
        *   `README.md` описывает CI/CD и процесс деплоя.
        *   Документация по деплою (`docs/deployment/...`) включает информацию о мониторинге, логировании, ресурсах и health checks.

*   **Задача 18 (обновленная): Финальное тестирование и деплой `web-api-service`.**
    *   **Дополнительное действие (DevSecOps):**
        *   **Интегрировать сканирование безопасности в CI/CD:**
            *   **Обновить `.github/workflows/ci_cd.yml`:**
                ```yaml
                jobs:
                  # ... (предыдущие job'ы: test, build-and-push-web-api и т.д.)

                  security-scan:
                    runs-on: ubuntu-latest
                    steps:
                      - uses: actions/checkout@v4
                      - name: Set up Python
                        uses: actions/setup-python@v4
                        with:
                          python-version: '3.11'
                      - name: Install security tools
                        run: |
                          pip install pip-audit bandit safety semgrep
                      - name: Run pip-audit
                        run: |
                          pip-audit -r requirements.txt
                          pip-audit -r dev-requirements.txt
                          # Запустить для каждого requirements_*.txt
                      - name: Run Bandit
                        run: |
                          bandit -r . -x ./venv,.venv,./node_modules
                      - name: Run Safety
                        run: |
                          safety check -r requirements.txt
                          safety check -r dev-requirements.txt
                      # - name: Run Semgrep (requires configuration)
                      #   run: |
                      #     semgrep ci --config=... # Указать путь к правилам

                  # ... (job деплоя)
                ```
        *   **Обновить `README.md`:**
            *   **Добавить раздел "Security Policy":** Как сообщать об уязвимостях.
    *   **Дополнительное действие (GitOps):**
        *   **Обновить `render.yaml`:**
            *   Убедиться, что все сервисы и их конфигурации (включая переменные окружения, health checks, планы) отражены точно.
        *   **Обновить `README.md`:**
            *   **Уточнить раздел "Infrastructure as Code (GitOps)":** Подчеркнуть, что *любые* изменения в инфраструктуре (план, переменные, команды запуска) должны вноситься *только* через изменения в `render.yaml` и последующий PR/Merge.
    *   **Acceptance (DevSecOps):**
        *   CI/CD pipeline включает автоматическое сканирование безопасности.
        *   `README.md` содержит политику безопасности.
    *   **Acceptance (GitOps):**
        *   `render.yaml` является *единственным источником истины* для конфигурации инфраструктуры на Render.
        *   Процесс изменения инфраструктуры задокументирован и подчиняется GitOps принципам.

Задача 18 (обновленная): Финальное тестирование и деплой web-api-service.
Дополнительное действие (UX/UI):
Создать docs/ux/04-style-guide.md:
Цель: Определить визуальный стиль PWA и Telegram Mini App (цвета, шрифты, иконки, размеры элементов, интервалы).
Содержимое: Палитра цветов, семейства шрифтов, размеры заголовков/текста, примеры кнопок, карточек, прогресс-баров.
Создать docs/ux/05-accessibility-guidelines.md:
Цель: Обеспечить доступность приложения для пользователей с ограниченными возможностями.
Содержимое: Использование семантической разметки HTML, aria-labels, контрастности цветов, поддержка клавиатуры (если применимо к PWA).
Обновить README.md:
Добавить раздел "UX/UI Principles": Краткое описание целей UX/UI (стильность, лаконичность, стремление к совершенству), ссылка на docs/ux/style-guide.md, docs/ux/accessibility-guidelines.md.

Задача 18 (обновленная): Финальное тестирование и деплой web-api-service.
Дополнительное действие (Экспертная оптимизация):
Создать docs/optimization/render-deployment-tuning.md:
Цель: Документировать настройки и практики, помогающие уложиться в лимиты Render и улучшить производительность.
Содержимое:
Использование pip cache purge в Dockerfile.
Многоступенчатая сборка.
.dockerignore.
Использование gunicorn с --worker-class uvicorn.workers.UvicornWorker и настройка количества воркеров (WEB_CONCURRENCY) и таймаутов (--timeout) в зависимости от типа инстанса Render (Free/Pro).
Мониторинг логов на Out of memory, WORKER TIMEOUT.
Использование healthcheckPath в render.yaml для быстрого обнаружения проблем.
(Если применимо) Использование preStop хука в Kubernetes (если Render когда-либо поддержит) для корректного завершения воркеров.
Обновить Makefile:
Добавить команды: profile-memory-web-api (например, запуск py-spy или memory_profiler на локальном образе), profile-cpu-web-api.
Обновить README.md:
Добавить раздел "Performance Tuning": Ссылки на docs/optimization/....
Acceptance (Экспертная оптимизация):
Существует документация по тюнингу для Render.
Существуют команды для профилирования.
README.md содержит ссылки на оптимизацию.

Задача 18 (обновленная): Финальное тестирование и деплой web-api-service.
Дополнительное действие (Пользовательские истории / Когнитивные техники):
Создать docs/ux/06-cognitive-features-validation.md:
Цель: План E2E тестов, проверяющих, работают ли когнитивные техники на практике.
Содержимое (пример):
Тест 1: Spaced Repetition. Пользователь решает задачу A, она становится "слабой". Через определенное время (согласно стратегии SR) задача A снова появляется в викторине.
Тест 2: Interleaving. Пользователь проходит викторину, задачи разных тем чередуются, а не группируются.
Тест 3: Immediate Feedback. Пользователь отправляет ответ, почти мгновенно получает is_correct и feedback.
Тест 4: Transfer Task. После ошибки на задачу X, пользователю предлагается похожая, но в новом контексте.
Тест 5: Worked Example. При запросе (например, кнопка "Показать решение"), пользователь получает структурированное объяснение.
Фокус (E2E тестирование): Эти тесты должны использовать TestClient для вызова API и проверять, что возвращаемые данные и состояние пользователя (в Supabase) соответствуют ожидаемому поведению когнитивных техник.
Обновить README.md:
Добавить раздел "Cognitive Features Implemented": Краткий обзор того, какие когнитивные техники реализованы и где в системе они происходят.