
#### **Задача 5 (обновленная): Обновить `services/answer_service.py`, использовать `common`. (Детализация)**

**Цель:** Обновить `AnswerService` для использования `checker_client` и нового `DatabaseManager` из `web-api-service`.

**Действия:**

1.  **Копирование `services/answer_service.py` в `web-api-service`:**
    *   **Команда:** `cp services/answer_service.py web-api-service/services/`
    *   **Обновление импортов в `answer_service.py`:**
        ```python
        # Было (или что-то подобное):
        # from utils.database_manager import DatabaseManager
        # from utils.answer_checker import FIPIAnswerChecker
        # from models.pydantic_models import CheckAnswerResponse, Feedback, ...

        # Стало:
        from web_api_service.database.database_manager import DatabaseManager # Или как у вас будет импортироваться
        from web_api_service.clients.checker_client import CheckerClient # Или как у вас будет импортироваться
        from common.models.pydantic_models import CheckAnswerRequest, CheckAnswerResponse, Feedback, Problem # Импортируем из common
        # ... другие импорты из common, если используются (например, SpecificationService, TaskNumberInferer)
        import logging

        logger = logging.getLogger(__name__)

        class AnswerService:
            def __init__(self, db_manager: DatabaseManager, checker_client: CheckerClient):
                self.db_manager = db_manager
                self.checker_client = checker_client
                # ... другие зависимости, возможно, из common

            async def check_answer(self, user_id: int, problem_id: str, user_answer: str) -> CheckAnswerResponse:
                # 1. Получить задачу (из Supabase через db_manager или кэша, если реализовано)
                # problem = await self.db_manager.get_problem_by_id(problem_id) # Если db_manager теперь читает задачи

                # 2. Вызвать checker_service
                task_id, subject = self._extract_task_id_and_subject(problem_id) # Или передать problem_id и subject отдельно, если checker_service может сам разобрать
                external_result = await self.checker_client.check_answer(task_id, user_answer, subject)

                # 3. Сохранить результат в Supabase (через db_manager)
                await self.db_manager.save_answer(user_id, problem_id, user_answer, external_result.is_correct)
                await self.db_manager.update_task_status(user_id, problem_id, "solved" if external_result.is_correct else "failed")

                # 4. Сформировать и вернуть ответ
                return CheckAnswerResponse(
                    problem_id=problem_id,
                    user_answer=user_answer,
                    is_correct=external_result.is_correct,
                    feedback=external_result.feedback, # Используем данные из ответа checker_service
                    # ... другие поля
                )

            def _extract_task_id_and_subject(self, problem_id: str) -> tuple[str, str]:
                # Реализуйте логику извлечения task_id и subject из problem_id
                # Это может быть в utils/task_id_utils.py -> common/utils/task_id_utils.py
                pass
        ```

2.  **Копирование `common` в `web-api-service` (если не копируется в Dockerfile):**
    *   **Команда:** `cp -r common web-api-service/`

**Acceptance:**

*   Файл `web-api-service/services/answer_service.py` обновлен.
*   Он импортирует `DatabaseManager` из `web-api-service/database/database_manager.py`.
*   Он импортирует `CheckerClient` из `web-api-service/clients/checker_client.py`.
*   Он импортирует `CheckAnswerRequest`, `CheckAnswerResponse`, `Feedback`, `Problem` из `common.models.pydantic_models`.
*   Его метод `check_answer` использует `self.checker_client.check_answer` и `self.db_manager.save_answer` / `update_task_status`.

---

(Фаза 2 продолжается: Задачи 9, 6, 7, 14, 15 будут детализированы аналогичным образом в следующем ответе, чтобы не превышать лимит длины.)